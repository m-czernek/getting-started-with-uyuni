:imagesdir: images
ifeval::["{docname}" == "index"]
:imagesdir: ch05/images
endif::[]

= Automating Tasks with Salt

{lm} uses Salt for communication, as well as code execution. For example, when installing packages remotely on a client, {lm} uses Salt to execute the package installation. Additionally, you can define your own custom Salt states and execute them on clients.

For example, consider a situation where you want to deploy a 3-tier application that consists of a web UI service, API service, and a database. You can create a Salt state that deploys all three applications on one system, and configure {lm} to execute the state on any client that is marked with the `server-role: test` label.

In addition, the Salt state can deploy and configure only one of the services, such as deploying the database when a client is marked with the `server-role: db-prod` label, or the web UI service when a client is makred with the `server-role: ui-prod` label.

Alternatively, consider a situation where you require a client to always have specific firewall configuration. You can create a Salt state that configures firewall, and configure {lm} to periodically execute the Salt state on the client. This means that if anyone manually changes the firewall configuration, for example by mistake, {lm} remedies the situation during the next periodic Salt state execution.

[TIP]
====
{lm} also enables you to use Ansible scripts instead of Salt states. This is useful when you already have Ansible scripts, or when you do not want to use Salt as the automation framework. However, this chapter focuses on Salt. 
====

== Understanding Salt Concepts

The following concepts enable you to automate code execution with Salt:

State::
--
A state footnote:[https://docs.saltproject.io/en/master/ref/states/writing.html] is a template file that specifies Salt modules for execution and arguments for the execution.

For example, the following state installs the `httpd` package:

[source,yaml]
----
install_apache: <.>
  pkg.installed: <.>
    - name: httpd <.>

configure_apache:
  file.managed:
    - name: /etc/httpd/conf.d/99_custom.conf
    - user: root
    - group: root
    - mode: 644
    - source: salt://salt/http_application.conf <.>
----
<.> ID of the execution step.
<.> Use the "installed" function from the "pkg" state module (https://github.com/openSUSE/salt/blob/openSUSE/release/3006.0/salt/states/pkg.py#L994).
<.> The function requires the "name" argument.
<.> The `source` argument uses `salt://` for files managed by Salt. {lm} enables you to store files that you later use in Salt states. The location of `salt://` is configurable footnote:[https://docs.saltproject.io/en/master/ref/configuration/master.html#std-conf_master-file_roots].

--

Highstate::
--
A highstate footnote:[https://docs.saltproject.io/en/master/ref/states/highstate.html] enables you to define a set of states that you want to execute against specific clients. This enables you to create small, reusable state files, and execute them in a selection and order that is necessary for your workflow. 

A highstate uses a `top.sls` file footnote:[https://docs.saltproject.io/en/master/ref/states/top.html#states-top] that maps what states are executed on what clients, for example:

[source,yaml]
----
base:
  '*': 
    - firewall <.>
  '*.devtest.tf.local':
    - devenv <.>
  'server-role: test': <.>
    - match: pillar
    - db
    - webapi
    - webui
----
<.> Execute the `firewall.sls` state on all clients.
<.> Execute the `devenv.sls` state on any clients with a name that ends if `devtest.tf.local`.
<.> Execute the `db.sls`, `webaip.sls`, and `webui.sls` states on any client that has the `server-role: test` pillar.

--

Grain::
A grain footnote:[https://docs.saltproject.io/en/master/topics/grains/index.html] is a `key: value` pair of data attached to a client. Salt calculates or stores this data is on a client.

Pillar::
A pillar footnote:[https://docs.saltproject.io/en/master/topics/tutorials/pillar.html] is a `key: value` pair of data attached to a client. Salt calculates or stores this data on the Salt master, which is the {lm} Server.
+
Pillars are useful, for example, for input variables into Salt states, because both Salt states and pillar data is stored on the Salt master.

== Managing Salt Content in {lm}

{lm} stores Salt states and files related to Salt files in a _State Channel_. When you create a state channel, {lm} creates the `/srv/susemanager/salt/$organization/$state_channel` directory. All content that you upload to that channel is stored in that directory, inside of the Server container.

.A Custom State Channel
image::salt-1.png[Creating a custom state channel]

The previous image displays the `example-channel` state channel, which contains an `init.sls` Salt state file. {lm} saves the files in the channel into the `/srv/susemanager/salt/manager_org_1/example-channel/` directory.

You can manually apply the state from the command line session inside of the Server container by using the `manager_org_1.example-channel` state name.

The following example executes the `/srv/susemanager/salt/manager_org_1/example-channel/init.sls` Salt state file on the `example-client.tf.local` client:

[source,none]
----
uyuni-server:/ # salt example-client.tf.local \
> state.apply manager_org_1.example-channel
...output omitted...
----

If you want to apply this state during every Salt highstate application, create the `/srv/salt/top.sls` file and specify client targets for the custom state. This means that during Salt highstate against that client, {lm} adds the custom state to the rest of the states that it executes against the client, for example:

[source,yaml]
----
base:
  'example-client.tf.local':
    - manager_org_1.example-channel
----

In that case, execute `salt example-client.tf.local state.apply` without specifying the custom state. This triggers the highstate execution, and Salt executes your custom state as the first state in the highstate commands:

[source,none]
----
uyuni-server:/ # salt example-client.tf.local state.apply 
example-client.tf.local:
----------
          ID: test-state <.>
    Function: test.succeed_without_changes
        Name: foo
      Result: True
     Comment: Success!
     Started: 13:10:53.463508
    Duration: 0.378 ms
     Changes:   
----------
          ID: sync_states <.>
    Function: saltutil.sync_states
      Result: True
     Comment: No updates to sync
     Started: 13:10:53.464268
    Duration: 123.373 ms
     Changes:   
...output omitted...  
----
<.> The custom state specified in the `top.sls` file.
<.> Rest of the states that {lm} configures as part of the Salt highstate execution.

You can execute Salt highstate from the web UI on any client, or group of clients. In addition, you can configure {lm} to execute a custom state periodically, outside of the highstate execution, provided that you subscribe that client to the state channel.

